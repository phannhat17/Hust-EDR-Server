# EDR System with ElastAlert Integration

A Python-based Endpoint Detection and Response (EDR) system with ElastAlert integration for enhanced alert management and rule configuration.

## Overview

This application provides a web interface for:

1. Viewing alerts generated by ElastAlert from Elasticsearch data
2. Managing and creating ElastAlert rules
3. Tracking alert status and analysis workflow

## Prerequisites

- Python 3.8+
- Elasticsearch 7.x
- ElastAlert 2.x (running separately)
- Docker (optional, for running ElastAlert in a container)

## Installation

1. Clone the repository:
   ```
   git clone https://github.com/yourusername/edr-python.git
   cd edr-python
   ```

2. Create a virtual environment:
   ```
   python -m venv venv
   source venv/bin/activate  # On Windows: venv\Scripts\activate
   ```

3. Install dependencies:
   ```
   pip install -r requirements.txt
   ```

4. Copy the example environment file and edit it:
   ```
   cp .env.example .env
   ```
   Update the values in `.env` to match your environment.

## Configuration

The system is configured using environment variables in the `.env` file:

### Flask Settings
- `FLASK_APP`: The Flask application entrypoint (default: `app.main`)
- `FLASK_ENV`: Environment setting (`development` or `production`)
- `FLASK_DEBUG`: Enable debug mode (1 for development, 0 for production)
- `FLASK_PORT`: Port to run the application on (default: `5000`)

### Elasticsearch Settings
- `ELASTICSEARCH_HOST`: Elasticsearch host (default: `localhost`)
- `ELASTICSEARCH_PORT`: Elasticsearch port (default: `9200`)
- `ELASTICSEARCH_USER`: Username for Elasticsearch authentication (if used)
- `ELASTICSEARCH_PASSWORD`: Password for Elasticsearch authentication (if used)
- `ELASTICSEARCH_USE_SSL`: Whether to use SSL for connecting to Elasticsearch (true/false)

### ElastAlert Settings
- `ELASTALERT_INDEX`: The index where ElastAlert stores alerts (default: `elastalert_status`)
- `ELASTALERT_RULES_DIR`: Directory where ElastAlert rule files are stored
- `ELASTALERT_DOCKER`: Whether ElastAlert is running in Docker (true/false)
- `ELASTALERT_CONTAINER`: Docker container name if running in Docker

## Running the Application

### Development mode
```
flask run --port=5000
```

### Production mode
For production deployment, use a WSGI server like Gunicorn:
```
gunicorn -w 4 -b 0.0.0.0:5000 app.main:app
```

## ElastAlert Setup

This application integrates with ElastAlert, which should be set up separately either on the host or in Docker.

### Using ElastAlert with Docker

1. Pull the ElastAlert Docker image:
   ```
   docker pull jertel/elastalert2
   ```

2. Create a configuration directory for ElastAlert:
   ```
   mkdir -p elastalert/config elastalert/rules
   ```

3. Create a `config.yaml` file in the `elastalert/config` directory with appropriate settings.

4. Run ElastAlert:
   ```
   docker run -d --name elastalert \
     -v $(pwd)/elastalert/config:/opt/elastalert/config \
     -v $(pwd)/elastalert/rules:/opt/elastalert/rules \
     -e "ELASTICSEARCH_HOST=your-elasticsearch-host" \
     -e "ELASTICSEARCH_PORT=9200" \
     jertel/elastalert2
   ```

## API Endpoints

The application provides the following API endpoints:

### Alerts
- `GET /api/alerts` - Get all alerts
- `PUT /api/alerts/:id` - Update alert status, notes, and assignment

### Rules
- `GET /api/rules` - Get all ElastAlert rules
- `GET /api/rules/:filename` - Get specific rule by filename
- `POST /api/rules` - Create new rule
- `PUT /api/rules/:filename` - Update existing rule
- `DELETE /api/rules/:filename` - Delete rule

### ElastAlert Management
- `POST /api/elastalert/restart` - Restart ElastAlert service (if configured)

## Alert Status Workflow

Alerts have the following status flow:

1. `new` - Newly detected alert
2. `in_review` - Alert being investigated
3. `in_progress` - Investigation is active
4. `resolved` - Issue has been resolved
5. `false_positive` - Alert determined to be a false positive

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

This project is licensed under the MIT License - see the LICENSE file for details. 